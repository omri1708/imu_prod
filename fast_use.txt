## בדיקת עשן:

    python -m engine smoke


## CLI על קבצים:

    python -m engine cli --program path/to/prog.json --payload path/to/payload.json


## Desktop UI (Tkinter):

    python -m engine desktop


## Web UI (אם FastAPI מותקן):

    python -m engine web --host 0.0.0.0 --port 8000


## Bootstrap סגור עם Proof-of-Convergence

    bash
    Copy code
    python -m engine.bootstrap


## אינטגרציית מיקרו־שירותים אמיתיים (תהליכים נפרדים + KPI):

    bash
    Copy code
    python -m tests.integration_micro
        – זה מריץ שני שרתים קטנים, מבצע קריאות אמת, וכותב KPI מתמשך.
        

Dashboard (יראה KPI/Φ ו-Alerts בזמן אמת):

    bash
    Copy code
    python -m engine web --host 127.0.0.1 --port 8000
        פתח בדפדפן: http://127.0.0.1:8000  


Workflow רב-שירותי (ירוץ עם Redis אמיתי אם Docker זמין; אחרת ייפול חכם ל-LocalQueue):

# בדיקת grounding קשיח:
    python -m tests.grounding_strict

# קריאות־משנה + מבני־נתונים
    python -m tests.vm_subroutines

# קונקרנציה + טיימרים + Grounding
    python -m tests.vm_concurrency

# Grounding קשיח (ללא ראיות → 412)
    python -m tests.grounding_strict

# Rollout מבוסס Φ (cand איטי → לא יקודם)

    python -m tests.load_phi_rollout

# תודעת־משתמש/זיכרון/פרטיות/רב־משתמש:
    python -m tests.user_profile


# VM מתקדם + Grounding קשיח (כפי שהוספנו בעבר):

    python -m tests.vm_subroutines
    python -m tests.vm_concurrency
    python -m tests.grounding_strict

# הכנת פיקטורה ל-httpcache ובדיקת אימות חיצוני קשיח:
    python -m tests.external_validation

# FS/NET Sandbox
    python -m tests.sandbox_io_net

# אורקסטרציה: יוצר docker-compose.yml ומנסה להריץ (אם Docker זמין)
    python -m tests.compose_stack

# imu_repo/tests/test_stage46_user_consolidation.py
from __future__ import annotations
import os, json, time, shutil, tempfile
from user_model.consolidation import Consolidator
from grounded.ttl import TTLPolicy

def run():
    tmp = tempfile.mkdtemp(prefix="imu_user_")
    try:
        cons = Consolidator(root=tmp)
        uid = "lea"

        # מוסיפים שלוש העדפות סותרות לאותה מפתח, עם trust/conf שונים
        cons.add_event(uid, "preference", {"key":"theme","value":"dark"}, confidence=0.9, trust=0.9, stable_hint=True)
        cons.add_event(uid, "preference", {"key":"theme","value":"light"}, confidence=0.4, trust=0.4)
        cons.add_event(uid, "preference", {"key":"theme","value":"dark"}, confidence=0.8, trust=0.7)

        # קונסולידציה → צפוי לבחור 'dark'
        out = cons.consolidate(uid)
        chosen = out["profile"]["preferences"]["theme"]["value"]
        ok1 = (chosen == "dark")

        # TTL: אירוע emotion עם ביטחון נמוך יתפוגג מהר (נכריז שעבר זמן)
        rec = cons.add_event(uid, "emotion", {"primary":"joy"}, confidence=0.3, trust=0.6)
        exp = rec["evidence"]["expire_ts"]
        # מזייפים “חלוף זמן” (נבדוק לוגית עם TTLPolicy.is_fresh)
        ok2 = TTLPolicy.is_fresh(exp)  # כרגע טרי
        ok = ok1 and ok2
        print("OK" if ok else "FAIL")
        return 0 if ok else 1
    finally:
        shutil.rmtree(tmp, ignore_errors=True)

if __name__=="__main__":
    raise SystemExit(run())

